<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Michelle Daily</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 16 Jun 2022 16:42:41 +0800</pubDate>
    <lastBuildDate>Thu, 16 Jun 2022 16:42:41 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>GO-序列化之Json</title>
        <description>&lt;h1 id=&quot;json&quot;&gt;JSON&lt;/h1&gt;

&lt;p&gt;JSON是一种简单的数据交换格式，它最常用于在浏览器中运行的Web后端和JavaScript程序之间的通信，是日常开发中使用最多的数据交换格式之一。
几乎所有现代编程语言都会对JSON的序列化方法内置于标准库中，Go也不例外。&lt;/p&gt;

&lt;h2 id=&quot;go语言中的json&quot;&gt;GO语言中的JSON&lt;/h2&gt;
&lt;p&gt;Go语言通过encoding/json 对外提供标准的 JSON 序列化和反序列化方法，其中最常用的是 encoding/json.Marshal 和 encoding/json.Unmarshal。&lt;/p&gt;

&lt;p&gt;JSON 反序列化的开销是序列化开销的好几倍，这是由于Go 语言中的 JSON
序列化过程不需要被序列化的对象预先实现任何接口，它会通过反射获取结构体或者数组中的值并以树形的结构递归地进行编码，标准库也会根据 encoding/json.Unmarshal 中传入的值对
JSON 进行解码。&lt;/p&gt;

&lt;p&gt;同时Go 语言 JSON 标准库编码和解码的过程大量地运用了反射这一特性。
我们先来简单介绍一下 JSON 标准库中的接口和标签，这两个特性可以让我们实现编码/解码的定制化。&lt;/p&gt;
&lt;h3 id=&quot;标签&quot;&gt;标签&lt;/h3&gt;
&lt;p&gt;在默认情况下，当我们在序列化和反序列化结构体时，标准库都会认为字段名和 JSON 中的键具有一一对应的关系，所以我们会使用标签这一特性，直接建立键与字段之间的映射关系。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Author struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    Name string &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;name,omitempty&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    Age  int32  &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;age,string,omitempty&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    Salary int32 &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;1.字段命名：默认json中的key与字段名一致，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;json:&quot;key名称&quot;&lt;/code&gt; 来指定。&lt;/p&gt;

&lt;p&gt;2.string标签：表示当前的整数或者浮点数是由 JSON 中的字符串表示的。&lt;/p&gt;

&lt;p&gt;3.omitempty标签：在字段为空值时，直接在生成的 JSON 中忽略对应的键值对，例如：”age”: 0、”author”: “” 等。&lt;/p&gt;

&lt;p&gt;4.忽略字段：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;json:&quot;-&quot;&lt;/code&gt;指定字段不参与序列化。&lt;/p&gt;

&lt;p&gt;标准库会使用如下所示的 encoding/json.parseTag 来解析标签，我们可以看出，
标签名和标签选项都以逗号连接，最前面的字符串为标签名，后面的都是标签选项&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func parseTag&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;tag string&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;string, tagOptions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;idx :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; strings.Index&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;tag, &lt;span class=&quot;s2&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; idx &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;tag[:idx], tagOptions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;tag[idx+1:]&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;tag, tagOptions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;接口&quot;&gt;接口&lt;/h3&gt;
&lt;h4 id=&quot;marshaler和unmarshaler接口&quot;&gt;Marshaler和Unmarshaler接口&lt;/h4&gt;
&lt;p&gt;在 JSON 序列化和反序列化的过程中，它会使用反射判断结构体类型是否实现了上述接口，如果实现了上述接口就会优先使用对应的方法进行编码和解码操作。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Marshaler interface &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	MarshalJSON&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;([]&lt;/span&gt;byte, error&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Unmarshaler interface &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	UnmarshalJSON&lt;span class=&quot;o&quot;&gt;([]&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; error
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面是一个示例，我们通过实现Marshaler和Unmarshaler对时间进行自定义的编码/解码。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package json_test

import &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;encoding/json&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;MyTime time.Time

&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Data struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	Id         int    &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;,string&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
	Name       string &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
	PrivateKey string &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
	Option1    string &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;,omitempty&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
	Option2    string &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;,omitempty&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
	Option3    string &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;json:&lt;span class=&quot;s2&quot;&gt;&quot;op3,omitempty&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
	Time       MyTime
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

var dateFormat &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; + &lt;span class=&quot;s2&quot;&gt;&quot;2006年01月02日 15:04:05&quot;&lt;/span&gt; + &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t MyTime&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; MarshalJSON&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;([]&lt;/span&gt;byte, error&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;time.Time&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.Format&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dateFormat&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;, nil
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;MyTime&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; UnmarshalJSON&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;b &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; error &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	temp, err :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; time.Parse&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dateFormat, string&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;err &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; nil &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;err
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;t &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; MyTime&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;temp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;nil
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

func main&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	data :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &amp;amp;Data&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		Id:         123,
		Name:       &lt;span class=&quot;s2&quot;&gt;&quot;aaa&quot;&lt;/span&gt;,
		PrivateKey: &lt;span class=&quot;s2&quot;&gt;&quot;pk&quot;&lt;/span&gt;,
		Option1:    &lt;span class=&quot;s2&quot;&gt;&quot;op111&quot;&lt;/span&gt;,
		Option3:    &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;,
		Time:       MyTime&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;time.Now&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;,
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	b, err :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; json.Marshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;err &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; nil &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		panic&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	fmt.Println&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Marshal: &quot;&lt;/span&gt;, string&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
	var newData Data
	&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;err :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; json.Unmarshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;b, &amp;amp;newData&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; err &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; nil &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		panic&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	fmt.Printf&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Unmarshal: %+v&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, newData&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Marshal:  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Id&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;123&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;aaa&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Option1&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;op111&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Time&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;2018年11月12日 16:52:59&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
Unmarshal: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;Id:123 Name:aaa PrivateKey: Option1:op111 Option2: Option3: Time:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;wall:0 ext:63677638379 loc:&amp;lt;nil&amp;gt;&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;textmarshaler和textunmarshaler接口&quot;&gt;TextMarshaler和TextUnmarshaler接口&lt;/h4&gt;
&lt;p&gt;TextMarshaler与Marshaler类似，优先级比Marshaler低。返回的是文本内容，不需要自己添加双引号。
上面例子中MyTime的MarshalJSON方法可以使用MarshalText代替：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t MyTime&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; MarshalText&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;([]&lt;/span&gt;byte, error&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;time.Time&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.Format&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2006年01月02日 15:04:05&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;, nil
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;总的来说，我们可以在任意类型上实现上述这四个方法自定义最终的结果，后面的两个方法的适用范围更广，但是不会被 JSON 标准库优先调用。&lt;/p&gt;

&lt;h1 id=&quot;序列化&quot;&gt;序列化&lt;/h1&gt;
&lt;p&gt;我们通过Marshal方法序列化JSON：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Marshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;v interface&lt;span class=&quot;o&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;([]&lt;/span&gt;byte, error&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们通过一个简单示例了解一下使用方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 定义一个Message结构体
&lt;span class=&quot;nb&quot;&gt;type &lt;/span&gt;Message struct &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    Name string
    Body string
    Time int64
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;初始化一个Message：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Message&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;EasyToGo&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;, 1294706395881547000&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
result, err :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; json.Marshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果一切运转正常，err会为null；result会是含有JSON数据的[]byte&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;EasyToGo&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Body&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Time&quot;&lt;/span&gt;:1294706395881547000&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;只有可以表示为有效 JSON 的数据结构才会被编码：&lt;/p&gt;

&lt;p&gt;1.只有 大写字母开头的字段 才会被 JSON 编码/解码如上段代码中的Name、Body、Time。&lt;/p&gt;

&lt;p&gt;2.无法对通道，复杂类型和函数类型进行编码。&lt;/p&gt;

&lt;p&gt;3.不支持循环数据结构；它们会导致 Marshal 函数陷入无限循环。&lt;/p&gt;

&lt;p&gt;4.JSON 对象仅支持将字符串作为键；要编码 Go 集合类型，它必须采用 map[string]T 的形式 (其中 T 是 JSON 程序包支持的任何 Go 类型)。&lt;/p&gt;

&lt;p&gt;#反序列化
为了解码 JSON 数据，我们使用 Unmarshal 函数&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Unmarshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;byte, v interface&lt;span class=&quot;o&quot;&gt;{})&lt;/span&gt; error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与执行过程确定的序列化相比，反序列化的过程是逐渐探索的过程，所以会复杂很多，开销也会高出几倍。因为反序列化的使用相对比较繁琐，所以需要传入一个变量帮助标准库进行反序列化：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//创建存储解码数据的变量
var message Message
err :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; json.Unmarshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;result, &amp;amp;message&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;若成功调用&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Message&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    Name: &lt;span class=&quot;s2&quot;&gt;&quot;EasyToGo&quot;&lt;/span&gt;,
    Body: &lt;span class=&quot;s2&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;,
    Time: 1294706395881547000,
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果JSON 数据的结构与 Go 类型不完全匹配时，Unmarshal 函数将仅解码在目标类型中可以找到的字段：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Michelle&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Age&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;20&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
var message Message
err :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; json.Unmarshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;result, &amp;amp;message&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，Unmarshal函数只会解码Name字段，age字段将被忽略。&lt;/p&gt;

&lt;h2 id=&quot;解码任意数据&quot;&gt;解码任意数据&lt;/h2&gt;
&lt;p&gt;接下来我们讨论一种常见情况：事先并不知道JSON中的数据格式和字段该怎么办？例如下面这段代码，假定它是一种未知结构，我们应该怎么进行编码/解码呢？&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Wednesday&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Age&quot;&lt;/span&gt;:6,&lt;span class=&quot;s2&quot;&gt;&quot;Parents&quot;&lt;/span&gt;:[&lt;span class=&quot;s2&quot;&gt;&quot;Gomez&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;Morticia&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们可以使用interface{}来进行解码，interface{}为空接口，go的每一种类型都实现了该接口，因此，任何其他类型的数据都可以赋值给interface{}类型。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var f interface&lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
// 使用interface&lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;来进行解码
err :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; json.Unmarshal&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;b, &amp;amp;f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
m :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; f.&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;map[string]interface&lt;span class=&quot;o&quot;&gt;{})&lt;/span&gt;
// 使用 range 语句遍历集合，根据类型的switch语句去获取正确的值。
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;k, v :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; range m &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    switch vv :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; v.&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; string:
        fmt.Println&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;k, &lt;span class=&quot;s2&quot;&gt;&quot;is string&quot;&lt;/span&gt;, vv&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; float64:
        fmt.Println&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;k, &lt;span class=&quot;s2&quot;&gt;&quot;is float64&quot;&lt;/span&gt;, vv&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;interface&lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;:
        fmt.Println&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;k, &lt;span class=&quot;s2&quot;&gt;&quot;is an array:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i, u :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; range vv &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            fmt.Println&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i, u&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    default:
        fmt.Println&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;k, &lt;span class=&quot;s2&quot;&gt;&quot;is of a type I don't know how to handle&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;
&lt;p&gt;1.JSON是一种树形的数据结构，无论是序列化还是反序列化，都会遵循自顶向下的编码和解码过程，使用递归的方式处理 JSON 对象。&lt;/p&gt;

&lt;p&gt;2.作为标准库的 JSON 提供的接口非常简洁，虽然它的性能相比于其他数据格式不算优秀，但是作为框架它提供了很好的通用性。&lt;/p&gt;

</description>
        <pubDate>Mon, 30 May 2022 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/05/30/JsonInGo/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/05/30/JsonInGo/</guid>
        
        <category>Go语言教程</category>
        
        
      </item>
    
      <item>
        <title>关于密码的那些事儿</title>
        <description>&lt;h1 id=&quot;关于密码的那些事儿&quot;&gt;关于密码的那些事儿&lt;/h1&gt;

&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;

&lt;p&gt;现在的各种网站和App都有登录注册or交易这种安全级别高的模块，如何保证用户的密码等隐私安全是很重要的部分。这篇文章介绍了web中关于密码的一些基础科普，包括以下几个部分：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. md5
	1. 什么是md5
	2. 如何破解md5
	3. 如何防范黑客攻击
2. HTTPS和SSL
3. web前端加密
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;md5&quot;&gt;md5&lt;/h2&gt;

&lt;p&gt;######1.什么是md5&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。&lt;/p&gt;

  &lt;p&gt;MD5由MD4、MD3、MD2改进而来，主要增强算法复杂度和不可逆性。&lt;/p&gt;

  &lt;p&gt;目前，MD5算法因其普遍、稳定、快速的特点，仍广泛应用于普通数据的错误检查领域。例如在一些BitTorrent下载中，软件将通过计算MD5检验下载到的文件片段的完整性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说，md5是一个加密算法，我们可以把它看做一个函数，举个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MD5(&quot;The quick brown fox jumps over the lazy dog&quot;)
= 9e107d9d372bb6826bd81d3542a419d6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;即使在原文中作一个小变化（比如用c替换d）其散列也会发生巨大的变化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MD5(&quot;The quick brown fox jumps over the lazy cog&quot;)
= 1055d3e698d289f2af8663725127bd4b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那么有一个小问题：
&lt;strong&gt;一般认为任何一个字符串都有一个对应的md5加密串&lt;/strong&gt;，md5的组成为32位十六进制数字，共有16^32 = 3.4 * 10^38 种可能，事实上有可数无穷多个字符串可以被md5加密，那么md5会存在不够用的问题吗？
实际上自然会有重复，但是md5的容量相当大，根据md5不可逆，很难反撸原串，所以在大多数使用情形下没有太大问题。&lt;/p&gt;

&lt;h6 id=&quot;2如何破解md5&quot;&gt;2.如何破解md5&lt;/h6&gt;

&lt;p&gt;以前的做法都是将所有可能出现的原文都分别算出md5值存储起来，用户可以用md5值索引可能的原文。但是md5的值太多了，所以这样会造成数据库太大，是一种资源浪费。&lt;/p&gt;

&lt;p&gt;上述的笨办法是建立描述“明文-&amp;gt;密文”对应关系的一个大型数据库，破解时通过密文直接反查明文。现在要介绍的是&lt;strong&gt;彩虹表&lt;/strong&gt;，彩虹表弥补了这样的不足，通过“&lt;strong&gt;以空间换时间&lt;/strong&gt;”的“&lt;strong&gt;双向交易&lt;/strong&gt;”来达到两者之间的平衡。&lt;/p&gt;

&lt;p&gt;彩虹表的前身是&lt;strong&gt;“预计算的哈希链集”&lt;/strong&gt;，以大量的随机明文作为起节点，通过计算得出哈希链并将&lt;strong&gt;起节点&lt;/strong&gt;和&lt;strong&gt;终节点&lt;/strong&gt;进行储存，即可得到一张&lt;strong&gt;哈希链集&lt;/strong&gt;。（计算过程略，感兴趣的同学可以自行google）&lt;/p&gt;

&lt;p&gt;每一条哈希链代表了一组属性相同的明文，每一个明文都可以通过&lt;strong&gt;起节点&lt;/strong&gt;计算得到，计算次数不大于链表长度，所以我们只需要保存其特征值（起节点和终节点），压缩空间为原来的1/k，达到了时间和空间的平衡。&lt;/p&gt;

&lt;h6 id=&quot;3如何防范黑客攻击&quot;&gt;3.如何防范黑客攻击&lt;/h6&gt;

&lt;p&gt;现在的主要方式是“加盐”（&lt;strong&gt;salt&lt;/strong&gt;），通过改变哈希函数H ,提高破解难度。另一种方法是&lt;strong&gt;提高H函数的计算难度&lt;/strong&gt;，比如将H定义为1000次md5之后的结果，生成彩虹表的时间会大大增加，也会提高破解难度。&lt;/p&gt;

&lt;p&gt;通俗点来说，彩虹表也是一种字典，不过是利用哈希链，只保存首尾节点，中间值通过哈希函数推算，因此节省了空间。&lt;/p&gt;

&lt;h3 id=&quot;2https和ssl简介&quot;&gt;2.https和ssl简介&lt;/h3&gt;

&lt;p&gt;上面介绍了md5相关的知识，作为前端该如何实践呢？拿登陆模块举例，在前端进行加密是否有必要呢？&lt;/p&gt;

&lt;p&gt;现在的登陆或者支付这种涉及安全性的模块，都会使用https，因为http的明文传输不安全。&lt;/p&gt;

&lt;p&gt;有一个常见的误区是：网站用了前端md5加密后就可以不用https了。这种说法错误的原因是：黑客在拿到你的md5值后依然可以伪造请求，由于他知道md5是在前端加密，所以并不需要利用彩虹表等技术推出原串，直接向服务器发送md5值就可以登录成功，所以这个md5值和明文没有大的差别。除了明文可以用来进行社会学攻击，因为大多数人的网站用的都是一个密码，简直是被一锅端了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;https&lt;/strong&gt;相当于http的安全版，它向http下加入了ssl（安全套接层），主要目的有两个：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.保证信息安全传输，创建安全连接，发送数据
2.确认网站的真实身份
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，被认为是安全的。&lt;/p&gt;

&lt;p&gt;而&lt;strong&gt;SSL&lt;/strong&gt;是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障，目前已成为互联网上保密通讯的工业标准。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;结论就是：对于密码等安全级别高的模块，使用https非常非常非常重要！！&lt;/p&gt;

&lt;h3 id=&quot;3web前端加密&quot;&gt;3.web前端加密&lt;/h3&gt;

&lt;p&gt;在写这个问题之前发现有一些争议，一部分人认为前端加密是无用的，因为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.有了https所以能够保证安全，不需要给系统加入额外的复杂性。
2.如上一段所说，用的如果是http，那么加不加密都能被黑客攻击，那为什么要加密呢？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我个人观点是前端加密，后端安全性防范，https缺一不可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.对于上面第一点，即使用了https，前端也需要加密，因为这样可以保证后端的日志等不会记录明文密码；还有保证后端内存中不存在明文密码（如dump），防止内鬼嘛。关于复杂性的问题，前端散列一般会采用较为“低功耗”的弱加密实现，而不会使用 RSA 等方法（有人使用短密钥的 RSA 依然是不安全的）。

2.对于上面第二点，如果用的是http，链路被监听时，可以直接拿明文密码，用户其他网站的密码很可能全部被暴露了。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有一种有效实践是发送用户密码+时间戳的md5值。这样可以有效避免被监听。攻击人拿到的加密后密码也很快失效，这里还有防止 replay 攻击（请求被重新发出一次即可能通过验证的问题）也解决了。&lt;/p&gt;

&lt;p&gt;所以我们现在给出的可行实践是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.客户端提交 md5(password) 密码，服务端数据库通过md5(salt+md5(password)) 的规则存储密码，该 salt 仅存储在服务端，且在每次存储密码时都随机生成。这样即使被拖库，制作字典的成本也非常高。
2.密码被 md5() 提交到服务端之后，可通过 md5(salt + form['password']) 与数据库密码比对。此方法可以在避免明文存储密码的前提下，实现密码加密提交与验证。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这篇文章就到此结束了，如有疏忽的地方请指教~&lt;/p&gt;

&lt;p&gt;资料来源：
&lt;a href=&quot;https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95#.E5.85.AC.E9.92.A5.E4.B8.8E.E7.A7.81.E9.92.A5.E7.9A.84.E4.BA.A7.E7.94.9F&quot;&gt;维基百科RSA加密算法&lt;/a&gt;
&lt;a href=&quot;https://zh.wikipedia.org/wiki/MD5#.E7.A2.B0.E6.92.9E&quot;&gt;维基百科md5&lt;/a&gt;
&lt;a href=&quot;https://www.zhihu.com/question/20060155&quot;&gt;知乎：如何保证用户登录时提交密码已经加密？&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 30 Mar 2019 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/30/password/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/30/password/</guid>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Michelle Blog</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;第一篇，抛弃了原来的阿里云，迁移到了Github Pages，很多东西需要慢慢捡起来~&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Mar 2019 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/29/hello-2015/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/29/hello-2015/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
